[
  {
    "objectID": "old-posts/trees1/index.html",
    "href": "old-posts/trees1/index.html",
    "title": "Making trees in the Jupyter notebook (part 1 - IToL)",
    "section": "",
    "text": "Let’s extend the previous post by scraping the CAZy website for accession numbers from genes in the glycoside hydrolase 5 (GH5) family. Then we can build a phylogenetic tree from these sequences and visualize how well the EC activities correspond to the phylogeny.\nUnfortunately the CAZy website spreads the information we need across multiple pages in tables that are not easily parsed. Luckily we have rvest. Let’s start by loading the libraries we’ll use.\n\n%load_ext rpy2.ipython\n\n\n%%R\nlibrary(rvest)\nlibrary(magrittr)\nlibrary(plyr); library(dplyr)\nlibrary(rentrez)\nlibrary(ggplot2)\nlibrary(rwantshue)\n\nCAZy distinguishes between genes that have been biochemically characterized and those that haven’t. For this analysis we’ll stick the characterized genes. This is the website that we’ll be scraping:\nwww.cazy.org/GH5_characterized.html\nAll we really need is a table of accessions and corresponding EC numbers but we might as well grab some other information provided by CAZy such as the subfamily membership of each gene and the organism.\nWe’ll start by creating a session from the webpage above.\n\n%%R\ncazy = html_session(\"http://www.cazy.org/GH5_characterized.html\")\n\nWe need to grab the links to the pages that contain continued sections for our table. I use Chrome’s inspector tools or the SelectorGadget to find the attributes and element data associated with the information I want to scrape. In this case, the webpage links we want are in span elements of the “pages” class. Each span element has a hyperlink tag (“a” below in html_nodes) and from that tag we want the value of the “href” attribute.\n\n%%R\nlinks = cazy %&gt;% html_nodes(\"span.pages a\") %&gt;% html_attr(\"href\")\nlinks\n\n[1] \"GH5_characterized.html?debut_PRINC=100#pagination_PRINC\"\n[2] \"GH5_characterized.html?debut_PRINC=200#pagination_PRINC\"\n[3] \"GH5_characterized.html?debut_PRINC=300#pagination_PRINC\"\n[4] \"GH5_characterized.html?debut_PRINC=400#pagination_PRINC\"\n[5] \"GH5_characterized.html?debut_PRINC=500#pagination_PRINC\"\n\n\nLet’s start by scraping the first page (the page we’re currently on).\nThe table has some rows that we don’t want (like the row that just points out the Domain of the organisms) which makes parsing this info a bit tricky. We need to scrub rows with the “royaume” class and rows with id “line_titre” (I think those are French words). So, to briefly summarize the command below, we’re grabbing rows (“tr”) from the table of class “listing” excluding rows of class “royaume” and id “line_titre”.\n\n%%R\nrows = cazy %&gt;% html_nodes(\"table.listing tr:not(.royaume)[id!=line_titre]\")\n\nWe’ll parse each row to get the accession, EC number, organism, and subfamily. I’m only grabbing the linked accession number. Some of the genes have multiple associated accession numbers but I think we’ll only need one. Also, I’m creating one row for each EC number so some of the genes will have two entries. I think I’ll eventually remove the genes with multiple EC activities from the tree but it might also be nice to point them out. Note how we use the extract2 function from magrittr to get the correct column.\n\n%%R\nget_data = function(row) {\n    cols = row %&gt;% html_nodes(\"td\")\n    ec = cols %&gt;% extract2(2) %&gt;% html_nodes(\"font.E\") %&gt;% html_text() %&gt;% unlist\n    organism = cols %&gt;% extract2(3) %&gt;% html_text(trim = TRUE)\n    acc = cols %&gt;% extract2(4) %&gt;% html_nodes(\"a b\") %&gt;% html_text()\n    if ( length(acc) == 0 )  {\n        acc = cols %&gt;% extract2(4) %&gt;% html_text() %&gt;% substr(1,10)\n    }\n    subf = cols %&gt;% extract2(7) %&gt;% html_text(trim = TRUE)\n    data.frame(ec=ec, organism=organism, acc=acc, subf=subf)\n}\n\nAnd now we’ll ldply it into a handy dataframe.\n\n%%R\ndf.pg1 = ldply(rows, get_data)\ndf.pg1 %&gt;% head\n\n        ec                                   organism        acc subf\n1  3.2.1.4        Desulfurococcaceae archaeon EBI-244 AEB53062.1     \n2  3.2.1.-            Halorhabdus utahensis DSM 12940 ACV12553.1     \n3  3.2.1.4                      Pyrococcus abyssi GE5 CAB49854.1    1\n4  3.2.1.4                  Pyrococcus horikoshii OT3 AAQ31833.1    1\n5 3.2.1.78                Acidothermus cellulolyticus ABJ41262.1    7\n6  3.2.1.4 Acidothermus cellulolyticus 11B ATCC 43068 AAA75477.1    1\n\n\nNow we need to do that for all the other pages of the table. This function uses jump_to to go to a link and extract the information we need with the same code as we had above. We can append our page 1 information with rbind and we’re ready to go.\n\n%%R\nget_df = function(link) {\n    session = jump_to(cazy, link)\n    rows = session %&gt;% html_nodes(\"table.listing tr:not(.royaume)[id!=line_titre]\")\n    rows %&gt;% head\n    ldply(rows, get_data)\n}\n\ndf.all = ldply(links, get_df) %&gt;% rbind(df.pg1)\ndf.all %&gt;% head\n\n        ec                             organism        acc subf\n1 3.2.1.78       Clostridium cellulovorans 743B ADL52789.1    7\n2 3.2.1.78       Clostridium cellulovorans 743B AAF06110.2   17\n3  3.2.1.4 Clostridium cellulovorans ATCC 35269 AAA23233.1    4\n4 3.2.1.73 Clostridium cellulovorans ATCC 35269 AAA23233.1    4\n5  3.2.1.8 Clostridium cellulovorans ATCC 35269 AAA23233.1    4\n6  3.2.1.4 Clostridium cellulovorans ATCC 35269 AAD39739.1    4\n\n\nWe now have all the information we need to make our tree in IToL that will give us a sense of how phylogenetically conserved the EC annotations are with phylogeny. But first let’s plot some counts of the different EC activities. There is clearly one predominant activity for this set of sequences.\n\n%%R -h 300 -w 600\ndf.all %&gt;%\n    group_by(ec) %&gt;%\n    summarize(count = n()) %&gt;% {\n        xsort = arrange(., desc(count)) %&gt;% extract2(\"ec\")\n        mutate(., ec = factor(ec, levels = xsort)) %&gt;%\n        ggplot(aes(x = ec, y = count)) +\n            geom_bar(stat = \"identity\") + \n            theme_bw() +\n            theme(axis.text.x = element_text(angle = 45, hjust = 1),\n                  axis.title = element_text(size = 16))\n    }\n\n\n\n\n\n\n\n\n\n%%R\ndf.all %&gt;% write.csv(\"data/GH5_data.csv\", row.names = FALSE, quote = FALSE)\n\nWe should add one more bit of information to the dataframe, the colors for each EC number. We need to send this information to IToL. Below I’m using rwantshue to get a list of colors the same length as the number of observed EC numbers. We collect the colors for each EC number in a dataframe and then we can join that colors dataframe to our CAZy dataframe. We’ll also save the IToL information to a file. I am making what IToL refers to as a “colors definition” file. This file should include (in order) a column for the tip names on the tree (in our case this will be accessions), a column specifying what you want to color (“range” here see IToL website for details), the actual color, and the label (EC numbers in our case).\n\n%%R\nN = df.all$ec %&gt;% unique %&gt;% length\nscheme &lt;- iwanthue()\ncolors = scheme$hex(N, color_space = hcl_presets$intense)\ncol.df = data.frame(\n    colors = colors,\n    ec = df.all$ec %&gt;% unique\n)\ndf.all %&gt;% \n    left_join(col.df) %&gt;%\n    mutate(ctype = \"range\", label = ec) %&gt;%\n    select(acc, ctype, colors, label) %&gt;%\n    group_by(acc) %&gt;% filter(row_number() == 1) %&gt;% # just grab the first row for each seq. \n                                                    # Some seqs have two EC numbers.\n    write.table(\"data/color_defs.tsv\", row.names = FALSE, col.names = FALSE, sep = \"\\t\", quote = FALSE)\n\nHere’s what that file looks like,\n\n!head -n5 data/color_defs.tsv\n\nADL52789.1  range   #4FB197 3.2.1.78\nAAF06110.2  range   #4FB197 3.2.1.78\nAAA23233.1  range   #CA55E1 3.2.1.4\nAAD39739.1  range   #CA55E1 3.2.1.4\nBAA12826.1  range   #CA55E1 3.2.1.4\n\n\nGreat! Now on to building the tree…\nWe need to get the sequences first. Let’s use rentrez to query Genbank for our accessions.\n\n%%R\naccs = df.all$acc %&gt;% as.character %&gt;% unique\nseqs = entrez_fetch(db=\"nucleotide\", id=accs, rettype=\"fasta\")\nwrite(seqs, \"data/GH5_characterized.fasta\")\n\n\n!head -n3 data/GH5_characterized.fasta\n\n&gt;gi|328834886|gb|AEB53062.1| putative glycoside hydrolase family 5 [Desulfurococcaceae archaeon EBI-244]\nMKKVHIIAIVVIIAIAFALILARYYTMQRGYETVTPTTPPQQTTTTETTPVPTEAGTTTPITEATVTQPP\nQTPTTPSPQTPTTPTALPTPSPTPTAPSATVTETTSPQTPTTTITTETTTTPAPQPQVVFLKLPEGEEPK\n\n\nI’m going to align these sequences with Muscle.\n\n!muscle -in data/GH5_characterized.fasta -out data/GH5_characterized.aln.fasta\n\n\n!head -n5 data/GH5_characterized.aln.fasta\n\n&gt;gi|190684977|gb|ACE82655.1| endo-1, 4-beta mannanase, man5C [Cellvibrio japonicus Ueda107]\n------------------------------------------------------------\n------------------------------------------------------------\n------------------------------------------------------------\n-------------------------------------------MKHLISPRILTGLFVIG\n\n\nOk, we’re going to switch into Python mode now as we have a look at this alignment. Also, we’ll use Python to talk to IToL. Let’s just plot gap frequency by position.\n\nfrom skbio.alignment import Alignment\nfrom skbio.sequence import DNA\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom itolapi import Itol, ItolExport\nfrom IPython.display import Image\n%matplotlib inline\n\n\naln = Alignment.read(file = \"data/GH5_characterized.aln.fasta\", format=\"fasta\")\n\nOur alignment is a bit gappy as you can see below. There are quite a few positions with few characters.\n\ngap_freq = [d[\"-\"] for d in aln.position_frequencies()]\nfig, ax = plt.subplots()\nfig.set_size_inches([16, 3])\nax.plot(np.arange(len(gap_freq)), gap_freq)\nax.set_xlabel(\"Position\")\nax.set_ylabel(\"Gap frequency\")\n\n\n\n\n\n\n\n\nLet’s make a gap frequency filter to remove columns with greater than 60% gaps.\n\nkeepers, = np.where(np.array(gap_freq)&lt;=0.60)\naln_masked = aln.subalignment(positions_to_keep=keepers)\n\nOk, that looks better. We’ll use this filtered alignment to build the tree.\n\ngap_freq2 = [d[\"-\"] for d in aln_masked.position_frequencies()]\nfig, ax = plt.subplots()\nfig.set_size_inches([16, 3])\nax.plot(np.arange(len(gap_freq2)), gap_freq2)\nax.set_xlabel(\"Position\")\nax.set_ylabel(\"Gap frequency\")\n\n\n\n\n\n\n\n\n\naln_masked.write(\"data/GH5_characterized.aln.masked.fasta\", format=\"fasta\")\n\n'data/GH5_characterized.aln.masked.fasta'\n\n\n\n!head -n2 data/GH5_characterized.aln.masked.fasta | cut -c1-100\n\n&gt;gi|190684977|gb|ACE82655.1| endo-1, 4-beta mannanase, man5C [Cellvibrio japonicus Ueda107]\nHLISPRILTGLFVIGLAPAWSSSVSSSGIIVGAQCNWYGPVCQSGASLPAPGNSVL-SGSSPEGNSWLSPYS-SKVMDGTASYAFAEATVPVTYQGQGDG\n\n\nI’m going to make the tree with FastTree. I’m doing a quick hack to make sure that the tips of our tree are just accession numbers and not the long identifiers returned from rentrez. The sed command just grabs the accession from each FASTA identifier line and scrubs the rest. I am using process substitution but you could just as easily write the scrubbed FASTA to a file and send it to FastTree.\n\n!head -n6 data/GH5_characterized.aln.masked.fasta | sed '/^&gt;/ s/.*|.*|.*|\\(.*\\)|.*/&gt;\\1/' | cut -c 1-80 #for example...\n\n&gt;ACE82655.1\nHLISPRILTGLFVIGLAPAWSSSVSSSGIIVGAQCNWYGPVCQSGASLPAPGNSVL-SGSSPEGNSWLSPYS-SKVMDGT\n&gt;AFR99035.1\n----MPPPPEVSPVTG-------------NPVSPHYIHS------STL-HFGRSLVLRGVN--EGFWFPLNLDDGSLARL\n&gt;BAG70961.1\nMKAMTSVILPPVAAPALCLAAV---------WTTFNAVG------ANL-G-GW---LIDTTGAVDEWCGPVLEWITIDTL\n\n\n\n%%bash\nFastTree &lt;(sed '/^&gt;/ s/.*|.*|.*|\\(.*\\)|.*/&gt;\\1/' data/GH5_characterized.aln.masked.fasta) &gt; data/GH5.tree 2&gt;/dev/null\n\nCool, now we just need to upload the tree and the color definition file from above to IToL. There is a nice Python library to talk to IToL programatically called itolapi. We’re using that to upload our info. The itolapi page has all the documentation required to use it effectively.\n\nitol_uploader = Itol.Itol()\nitol_uploader.add_variable('treeFile', 'data/GH5.tree')\nitol_uploader.add_variable('treeFormat', 'newick')\nitol_uploader.add_variable('treeName', 'GH5')\nitol_uploader.add_variable(\"colorDefinitionFile\", \"data/color_defs.tsv\")\nstatus = itol_uploader.upload()\nitol_uploader.comm.upload_output\nprint itol_uploader.get_webpage()\n\nhttp://itol.embl.de/external.cgi?tree=128841252312946714389719820&restore_saved=1\n\n\nYou can also use itolapi to download the tree but I don’t think the IToL API supports exporting trees with full clade coloring. I could be wrong but I really wanted the full clade coloring as opposed to just a ring of colors around the tree. Anyway, I had to manually visit IToL to export this visualization (frown).\n\nImage(\"data/GH5.tree.png\", width=600)\n\n\n\n\n\n\n\n\nSo it looks like there’s some coherence to the EC numbers. The two main EC annotations do not appear to overlap much but the minor annotations are dispersed throughout in small groups.\nYou can explore this tree in IToL by visiting this page.\nDisclaimer: I don’t want to go down the rabbit hole of finding all the inconsistencies in this CAZy table for this small example. There are most definitely some wonky rows in the information we scraped. I think the accessions are the least consistent field in CAZy and it’s tiresome to account for all the seemingly arbitrary little ways that rows can differ from the consensus. The moral of the story? Don’t make people scrape your webpage to get information!!! I don’t see why that table can’t be provided by the CAZy team as a nice CSV…"
  },
  {
    "objectID": "old-posts/melt/index.html",
    "href": "old-posts/melt/index.html",
    "title": "Melting your phyloseq object with dplyr/tidyr",
    "section": "",
    "text": "If you’re a microbial ecologist and you haven’t used phyloseq, put away your vintage scarf and thick-rimmed glasses because you are not hip. phyloseq is the nexus of all that is good in the universe. In this post we’ll look at one of the greatest phyloseq functions, psmelt. psmelt combines your sample info, OTU counts, and taxonomic annotations into a single dataframe where every row represents an OTU-sample combination. Hhhhwhat!?! Amazing, I know. From this omnipotent dataframe you can do anything. So, how do we use psmelt? And can we re-create psmelt with dplyr and tidyr?\nLet’s start by bringing in some R packages and loading the rmagic extension for IPython.\n\n%load_ext rpy2.ipython\n\n\n%%R\nlibrary(phyloseq)\nlibrary(dplyr); library(tidyr)\nlibrary(magrittr)\nlibrary(ggplot2)\n\nI’m going to use data from a paper we recently submitted. See the pre-print here if you’re interested. A typical microbiome data set consists of three tables:\n\nA table of sample information.\nA table of OTU counts in the samples.\nA table of taxonomic info for each OTU.\n\nIn this example the OTU counts and taxonomic info are combined in a json biom formatted table. We have the sample information in a QIIME formatted sample metadata table. Don’t get bogged down in the file formats, however. They’re just tables and you can get tables into R easily. Focus on the concepts and what information you need to do an analysis.\nWe’ll write a quick function to handle the QIIME formatted sample data table (note how we’re just using the base R read.table function) and we’ll use the import_biom function from phyloseq to import our OTU counts and OTU taxonomic annotations. We’ll combine all the info into a phyloseq object.\n\n%%R\nread.qiime = function(fn) {\n    read.table(fn, sep = \"\\t\", comment = \"\", header = TRUE, stringsAsFactors = FALSE) %&gt;%\n    rename(SampleID = X.SampleID) %&gt;%\n    {rownames(.) = .$SampleID; .} %&gt;%\n    data.frame %&gt;% sample_data\n}\n\nphyseq = import_biom(\"data/otu_table_wtax.biom\")\nsample_data(physeq) = read.qiime(\"data/sample_data_combined_qiime_format.tsv\")\nphyseq\n\nphyloseq-class experiment-level object\notu_table()   OTU Table:         [ 4340 taxa and 158 samples ]\nsample_data() Sample Data:       [ 158 samples by 46 sample variables ]\ntax_table()   Taxonomy Table:    [ 4340 taxa by 8 taxonomic ranks ]\n\n\nGreat! Now let’s melt all that information into an all-powerful, all-knowing, benevolent dataframe. (Evil laugh)\n\n%%R\nmdf = psmelt(physeq)\nmdf %&gt;% select(OTU, SampleID, Abundance) %&gt;% head\n\n              OTU  SampleID Abundance\n20025    OTU.1106 4502024.3      2233\n288    DQ531697.1    site16      2147\n19962    OTU.1106    site19      1505\n272    DQ531697.1    site15      1426\n310    DQ531697.1    site17      1278\n456836     OTU.36    site19      1268\n\n\nTo keep this post short, I won’t demonstrate where you can go from a melted phyloseq object. Suffice to say that you can go anywhere with your melted phyloseq object/dataframe. Think of it like a magic carpet.\nWith really big OTU tables, melting can take a long time…\n\n%%R\nsystem.time(psmelt(physeq))\n\n   user  system elapsed \n 22.660   0.056  22.728 \n\n\nIt takes about 30-ish seconds with our example phyloseq object with the psmelt function. I wonder how fast dplyr + tidyr can melt our phyloseq object?\nLet’s re-create the psmelt function with dplyr + tidyr.\nWe need to,\n\nget our tables (sample data, OTU counts, taxonomy),\ncombine our taxonomic info with our OTU counts,\ngather this combined table into a long form version, and\nadd in the sample data.\n\n\n%%R\npsmelt.dplyr = function(physeq) {\n    sd = data.frame(sample_data(physeq))\n    TT = data.frame(tax_table(physeq)) %&gt;% add_rownames(\"OTU\")\n    otu.table = data.frame(otu_table(physeq), check.names = FALSE) %&gt;% add_rownames(\"OTU\")\n    otu.table %&gt;%\n        left_join(TT) %&gt;%\n        gather_(\"SampleID\", \"Abundance\", setdiff(colnames(otu.table), \"OTU\")) %&gt;%\n        left_join(sd)\n}\n\n\n%%R\nmdf.dplyr = psmelt.dplyr(physeq)\nmdf.dplyr %&gt;% select(OTU, SampleID, Abundance) %&gt;% head\n\nJoining by: \"OTU\"\nJoining by: \"SampleID\"\n       OTU SampleID Abundance\n1  OTU.758    G4F20         2\n2 OTU.2942    G4F20         0\n3  OTU.753    G4F20         0\n4  OTU.752    G4F20         0\n5  OTU.751    G4F20         0\n6  OTU.750    G4F20         0\n\n\n…and let’s see how fast it is.\n\n%%R\nsystem.time(psmelt.dplyr(physeq))\n\nJoining by: \"OTU\"\nJoining by: \"SampleID\"\n   user  system elapsed \n   1.04    0.00    1.04 \n\n\nWow. Roughly an order of magnitude faster. dplyr and tidyr are so great. And look at that syntax!\nI shold note that I’m using phyloseq version 1.9.15 in this demo.\nThe psmelt function is so useful (and much more rigorous/fool-proof than our quick dplyr/tidyr version) but if you have a huge phyloseq object that takes forever to melt, try dplyr + tidyr.\nLet’s do one quick example from the melted phyloseq object to give you a taste of how useful it is. Let’s say we want to make phylum level stacked bar charts for all the studies in the example data. Here’s how you might do it from the melted phyloseq object.\n\n%%R -w 1200\nd = mdf.dplyr %&gt;%\n    group_by(SampleID, Rank2) %&gt;%\n    filter(Abundance &gt; 0) %&gt;%\n    summarize(rank2.abund = sum(Abundance), study = first(study)) %&gt;%\n    mutate(relative.abundance = rank2.abund / sum(rank2.abund))\n\np = ggplot(d, aes(x = SampleID, y = relative.abundance, fill = Rank2)) +\n    facet_grid(.~study, drop = TRUE, space = \"free\", scales = \"free\") +\n    geom_bar(stat = \"identity\", width = 0.85) + \n    theme_bw() + theme(axis.text.x = element_blank(), legend.position = \"none\", strip.background = element_blank())\np\n\n\n\n\n\n\n\n\nSnap.\n\n%%R\npckgs  = lapply(names(sessionInfo()$otherPkgs), packageVersion)\nnames(pckgs) = names(sessionInfo()$otherPkgs)\ndata.frame(pckgs)\n\n  ggplot2 magrittr tidyr dplyr phyloseq\n1   1.0.0      1.5 0.2.0 0.4.1   1.9.15"
  },
  {
    "objectID": "old-posts/primers1/index.html",
    "href": "old-posts/primers1/index.html",
    "title": "Exploring 515F primer targets in archaeal and bacterial SSU rRNA genes",
    "section": "",
    "text": "Microbial ecologists have long considered the 515F SSU rRNA gene PCR primer to be “universal.” That is, the 515F primer is thought to amplify Eukarya, Archaea, and Bacteria. Indeed the target of the 515F primer is well conserved across each domain, however, the there are some differences in the primer target between domains that should be considered when evaluating 515F for use in a microbial diversity studies.\nTo make matters more complicated the 515F primer has changed from its inception to account for new sequence information and it’s not clear from the literature which 515F version is most effective. In this post, we’ll take a look at tbe 515F primer target across a broad diversity of SSU rRNA genes. In subsequent posts we’ll evaluate different 515F versions and we’ll also evaluate reverse primers that can be paired with 515F. While there are excellent tools avaliable for SSU rRNA gene PCR primer analysis (see PrimerProspector, TestPrime), most tools focus on nucleotide frequecies in aligments. In this post, we’ll evaluate 515F by looking at the distribution of 515F target oligos.\nWe’ll use the 99% OTU seed sequences for the GreenGenes database as reference. You can download the GreenGenes files from here. This analysis will focus on Archaea and Bacteria.\nFirst we need to import some python functions and modules as well as load some extensions for the IPython notebook.\n\n%matplotlib inline\n%load_ext rpy2.ipython\nimport matplotlib.pyplot as plt\nimport re\nfrom align import aligner\nfrom skbio import DNA, parse_fasta, SequenceCollection\nimport pandas as pd\n\nEventually we’ll want to explore target sites by their taxonomic affiliation so we need to get the taxonomic information from the GreenGenes files we downloaded (above). The following code is a quick and dirty way to populate a pandas DataFrame with the taxonomic annotations for the gene sequences we’ll be working with.\n\ndef parse_tax(line):\n    id, tax_str = line.split(\"\\t\")\n    k, p, c, o, f, g, s = tax_str.rstrip().split(\";\")\n    tax_dict = {\"kingdom\" : k.split(\"__\")[1],\n                \"phylum\"  : p.split(\"__\")[1],\n                \"class\"   : c.split(\"__\")[1],\n                \"family\"  : f.split(\"__\")[1],\n                \"order\"   : o.split(\"__\")[1],\n                \"genus\"   : g.split(\"__\")[1],\n                \"species\" : s.split(\"__\")[1],\n                \"id\"      : id}\n    return tax_dict\n    \n\ndf = pd.DataFrame.from_records([parse_tax(line) for line in \n                                open(\"data/gg_13_5_otus/taxonomy/99_otu_taxonomy.txt\")])\n\ndf.set_index(\"id\", inplace=True)\n\nNow that we have the taxonomy for each sequence, let’s get the 515F target site. To do this we just align one combination of the degenerate 515F primer to each SSU rRNA gene sequence. We then pull out the aligned region from the SSU rRNA gene sequence – this is the 515F target! I’m using the glocal method for the Python aligner package for the alignment and I’m using scikit-bio to parse and manage the SSU rRNA gene sequenes.\n\nfn = \"data/gg_13_5_otus/rep_set/99_otus.fasta\"\ndegens = DNA.iupac_degenerate_characters()\nseqs = SequenceCollection.from_fasta_records([(n, s) for n, s in parse_fasta(fn) \n                                              if not any(i in s for i in degens)], \n                                             DNA)\n\nids = [seq[0] for seq in seqs.iteritems()]\n\n\n%%time\nF515 = DNA(\"GTGCCAGCCGCCGCGGTAA\") #GTGCCAGCMGCCGCGGTAA  M = [CA]\n\nprimer_targets_515 = [aligner(F515.sequence, \n                              seq[1].sequence,\n                              method = \"glocal\")[1] \n                      for seq in seqs.iteritems()]\n\nCPU times: user 20min 29s, sys: 112 ms, total: 20min 30s\nWall time: 20min 31s\n\n\nNow we can join our target and taxonomy information into a single DataFrame. Each row represents one target from one gene. Specifically, each row has the target sequence and corresponding taxonomic information.\n\ndf_targets = df.join(pd.Series(primer_targets_515, index=ids, name = \"515F\"), how = \"left\")\ndf_targets.dropna(axis=0, subset=[\"515F\"], inplace=True)\n\nI love pandas but I think for this application it will be best to use the (mind-blowingly amazing) R package dplyR. So, we need to push our pandas DataFrame into an R session. I’m using the rmagic functions from IPython/rpy2 to move from Python to R.\n\n%R -i df_targets\n\n\n%%R\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggthemes)\nlibrary(magrittr)\n\nOk, now we can make some figures! Let’s first look at the ten most abundant archaeal and bacterial 515F targets. You can see below that the bacterial 515F targets are dominated by a single sequence, and, that although the nineteen targets are similar in sequence there is little overlap in target representation between Archaea and Bacteria.\n\n\nCode\n%%R -w 600\nd = df_targets %&gt;%\n    group_by(kingdom, X515F) %&gt;%\n    summarize(count = n()) %&gt;%\n    filter(rank(desc(count), ties.method = \"random\") &lt;= 10) %&gt;%\n    arrange(desc(count), kingdom) %&gt;%\n    mutate(X515F = factor(X515F, levels = unique(.$X515F)))\n\np = ggplot(d, aes(x = X515F, y = count))\n\np = p + facet_wrap(~kingdom, ncol = 1, scales = \"free_y\")\n\np = p + geom_bar(stat = \"identity\", fill = \"#14979B\")\n\np = p + labs(x = \"\")\n\np = p + scale_y_log10()\n\np = p + theme_bw()\n\np = p + theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 12),\n              axis.text.y = element_text(size = 12),\n              axis.title = element_text(size = 16),\n              strip.background = element_blank(),\n              strip.text = element_text(size = 16))\n                                    \np\n\n\n\n\n\n\n\n\n\nIf we dig a little deeper into to archaeal 515F targets, we see some interesting trends among phyla. There are very few Nanoarchaea sequences in the reference database but they all have the same 515F target sequence which appears to be unique to Nanoarchaea. Also, there are a couple relatively abundant 515F target sequences with insertions. Eight of the ten most abundant archaeal 515F targets are identical over the last six nucleotides at the 3’ end of the 515F primer.\n\n\nCode\n%%R -h 550 -w 400\nd = df_targets %&gt;%\n    filter(kingdom == \"Archaea\", phylum != \"\") %&gt;%\n    {\n        top10 = group_by(., X515F) %&gt;%\n            summarize(count = n()) %&gt;%\n            filter(rank(desc(count), ties.method = \"random\") &lt;= 10) %&gt;%\n            extract2(\"X515F\") %&gt;% \n            unique %&gt;%\n            as.character\n        filter(., X515F %in% top10) \n    } %&gt;%\n    group_by(phylum, X515F) %&gt;%\n    summarize(count = n()) %&gt;%\n    {\n        psort = group_by(., X515F) %&gt;%\n            summarize(S = sum(count)) %&gt;%\n            arrange(desc(S)) %&gt;%\n            extract2(\"X515F\") %&gt;% as.character\n        mutate(., X515F = factor(X515F, levels = psort))\n    }\n\np = ggplot(d, aes(x = X515F, y = count))\n\np = p + facet_wrap(~phylum, ncol = 1, scales = \"free_y\")\n\np = p + geom_bar(stat = \"identity\", fill = \"#14979B\")\n\np = p + labs(x = \"\")\n\np = p + scale_y_log10()\n\np = p + theme_bw()\n\np = p + theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 12),\n              axis.text.y = element_text(size = 12),\n              axis.title = element_text(size = 16),\n              strip.background = element_blank(),\n              strip.text = element_text(size = 16))\n\np\n\n\n\n\n\n\n\n\n\nThe Bacteria appear to be dominated by a single target sequence (above). Let’s get that sequence explicitly.\n\n%%R\nmax.target = df_targets %&gt;%\n    filter(kingdom == \"Bacteria\") %&gt;%\n    group_by(X515F) %&gt;%\n    summarize(count = n()) %&gt;%\n    arrange(desc(count)) %&gt;%\n    filter(rank(desc(count)) == 1) %&gt;%\n    extract2(\"X515F\") %&gt;% as.character\n\npaste(\"The most abundant target sequence among bacteria is\", max.target)\n# &lt;!-- collapse=True --&gt;\n\n[1] \"The most abundant target sequence among bacteria is GTGCCAGCAGCCGCGGTAA\"\n\n\nThere are some phyla, however, that are not as dominated by the most abundant bacterial 515F target. Here is a histogram of representation (percentages of total targets) within phylum for the most abundant bacterial 515F target. You can see that there are nine phyla for which the most abundant 515F bacterial target represents less than 80% of total targets.\n\n%%R -h 350\ndf_targets %&gt;%\n    filter(kingdom == \"Bacteria\", phylum != \"\" ) %&gt;%\n    group_by(phylum, X515F) %&gt;%\n    summarize(count = n()) %&gt;%\n    group_by(phylum) %&gt;%\n    mutate(count.relative = count / sum(count)) %&gt;%\n    filter(X515F == max.target) %&gt;%\n    extract2(\"count.relative\") %&gt;% hist(breaks = 50,\n                                        main = \"Histogram of most abundant target representation in phlya\")\n# &lt;!-- collapse=True --&gt;\n\n\n\n\n\n\n\n\nLet’s see what the 515F targets look like for those nine phyla (above). The plot below shows the five most abundant 515F targets ranked by max representation within a phylum for the nine selected phyla. You can see that FCPU426, WS5, and GN01 515F targets are still dominated by the most abundant 515F target across all bacteria (GTGCCAGCAGCCGCGGTAA). The TM7 phylum 515F targets differ from the most abundant target at the 3’ end of the 515F primer.\n\n\nCode\n%%R -w 600 -h 500\nd = df_targets %&gt;%\n    filter(kingdom == \"Bacteria\", phylum != \"\" ) %&gt;%\n    group_by(phylum, X515F) %&gt;%\n    summarize(count = n()) %&gt;%\n    group_by(phylum) %&gt;%\n    mutate(count.relative = count / sum(count)) %&gt;%\n    {\n        keep = filter(., X515F == max.target, count.relative &lt;= 0.80) %&gt;%\n            extract2(\"phylum\") %&gt;% \n            unique %&gt;%\n            as.character\n        filter(., phylum %in% keep)\n    } %&gt;%\n    {\n        top = group_by(., X515F) %&gt;%\n            summarize(m = max(count.relative)) %&gt;%\n            filter(rank(desc(m), ties.method = \"random\") &lt;= 5) %&gt;%\n            arrange(desc(m)) %&gt;%\n            extract2(\"X515F\") %&gt;% \n            unique %&gt;%\n            as.character\n        filter(., X515F %in% top) %&gt;% mutate(X515F = factor(X515F, levels = top))\n    }\n\np = ggplot(d, aes(x = X515F, y = count.relative))\n\np = p + facet_wrap(~phylum, ncol = 3, scales = \"free_y\")\n\np = p + geom_bar(stat = \"identity\", fill = \"#14979B\")\n\np = p + labs(x = \"\")\n\np = p + theme_bw()\n\np = p + theme(axis.text.x = element_text(angle = 65, hjust = 1, size = 12),\n              axis.text.y = element_text(size = 12),\n              axis.title = element_text(size = 16),\n              strip.background = element_blank(),\n              strip.text = element_text(size = 16))\n\np\n# &lt;!-- collapse=True --&gt;\n\n\n\n\n\n\n\n\n\nI would guess that these nine phyla are the most likely to be missed by commonly used variants of 515F primers.\nIn the next post we’ll test that hypothesis by evaluating how well the 515F primer matches the targets we’ve identified…"
  },
  {
    "objectID": "til/fish-func-to-select-tmux-sess/index.html",
    "href": "til/fish-func-to-select-tmux-sess/index.html",
    "title": "A Fish Shell function to select and enter tmux sessions",
    "section": "",
    "text": "This fish shell function gets the name of current tmux sessions and pipes the session names into the fzf prompt. The user is attached to the the tmux session selected in fzf.\nfunction tma\n    set sessions (tmux ls -F '#{session_name}')\n    set session (printf %s\\n $sessions | fzf --prompt=\" Tmux session \" --height=50% --layout=reverse --border --exit-0)\n    if set -q TMUX\n        set tmux_cmd switchc\n        echo \"In a tmux session: $TMUX\"\n    else\n        set tmux_cmd attach\n        echo \"Not in a TMUX session\"\n    end\n    tmux $tmux_cmd -t $session\nend"
  },
  {
    "objectID": "til/iconify-titles/index.html",
    "href": "til/iconify-titles/index.html",
    "title": "Adding custom hover text to iconify icons",
    "section": "",
    "text": "I like having icons instead of text in my blog’s navbar. I use the iconify extenion for icons but when I was first adding icons to my blog I noticed the hover text from my browser was not helpful.\n\n\n\nThe default hover text is just the full name/description of the image.\n\n\nUpon reading the iconify README, I learned I can control hover text with a title key. E.g.:\n# note the title key in the line below\n{{&lt; iconify ph:lightbulb-bold title=TIL label=TIL size=Large &gt;}}\nThe snippet above would create hover text like this .\n\n\n\nAfter setting the title key, the hover text is much more useful."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "chuckpr blog",
    "section": "",
    "text": "Warning\n\n\n\n This site is under construction. Some possts are just placeholders."
  },
  {
    "objectID": "index.html#latest-in-today-i-learned..",
    "href": "index.html#latest-in-today-i-learned..",
    "title": "chuckpr blog",
    "section": " Latest in Today I Learned..",
    "text": "Latest in Today I Learned..\n\n\n\n  Oct 3, 2024 — A Fish Shell function to select and enter tmux sessions \n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#posts",
    "href": "index.html#posts",
    "title": "chuckpr blog",
    "section": " Posts",
    "text": "Posts\n\n\n\n  Sep 20, 2024 — Post With Code \n\n\n  Sep 17, 2024 — Welcome To My Blog \n\n\n\nNo matching items"
  },
  {
    "objectID": "til.html",
    "href": "til.html",
    "title": "Today I learned…",
    "section": "",
    "text": "Today I learned…\nBelow are small posts to record the small things I learn .\n\n\n\n\n\n\n\n\n  Oct 3, 2024 — A Fish Shell function to select and enter tmux sessions \n\n\n  Sep 30, 2024 — Adding custom hover text to iconify icons \n\n\n  Sep 26, 2024 — Pivot longer-ing in Polars \n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n\n\n\nprint(\"ONE\")\n\n[1] \"ONE\"\n\n\n\n\n\nprint(\"ONE\")\n\n[1] \"ONE\""
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "TODO.html",
    "href": "TODO.html",
    "title": "chuckpr blog",
    "section": "",
    "text": "add .envrc and activate blog environment\nadd old primers2 post\nremove placeholder posts\niconify\nfooter\nsocial links\n\ngithub\nlinkedin\n\nTIL on adding title/label to iconify icons\nadd melt old post\nfinish about page\nadd CV\nadd courses page\nfish function to select from running terminal sessions"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "chuckpr blog",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "til/pivot-longer-polars/index.html",
    "href": "til/pivot-longer-polars/index.html",
    "title": "Pivot longer-ing in Polars",
    "section": "",
    "text": "The Polars equivalent for pivot_longer from dplyR is melt.\n\ndplyrR example (R)\n\nsuppressPackageStartupMessages(\n  library('tidyverse')\n)\n\notter_data = read_csv(\n  'https://raw.githubusercontent.com/jcoliver/learn-r/gh-pages/data/otter-mandible-data.csv',\n  col_types = cols()\n)\n\notter_data |&gt;\n  pivot_longer(cols = matches('m\\\\d')) |&gt;\n  head() |&gt;\n  gt::gt()\n\n\n\n\n\n\n\nspecies\nmuseum\naccession\nname\nvalue\n\n\n\n\nA. cinerea\nAMNH\n101458\nm1\n15.100\n\n\nA. cinerea\nAMNH\n101458\nm2\n27.790\n\n\nA. cinerea\nAMNH\n101458\nm3\n21.885\n\n\nA. cinerea\nAMNH\n101458\nm4\n13.010\n\n\nA. cinerea\nAMNH\n101458\nm5\n10.500\n\n\nA. cinerea\nAMNH\n101458\nm6\n61.635\n\n\n\n\n\n\n\n\n\nPolars example (Python)\n\nimport polars as pl\nfrom great_tables import GT\n\n(\n  pl.read_csv(\n    'https://raw.githubusercontent.com/jcoliver/learn-r/gh-pages/data/otter-mandible-data.csv',\n    null_values='NA'\n  )\n  .melt(id_vars=['species', 'museum', 'accession'])\n  .head()\n  .pipe(lambda df_: GT(df_))\n)\n\n\n\n\n\n\n\nspecies\nmuseum\naccession\nvariable\nvalue\n\n\n\n\nA. cinerea\nAMNH\n101458\nm1\n15.1\n\n\nA. cinerea\nAMNH\n101461\nm1\n12.74\n\n\nA. cinerea\nAMNH\n101466\nm1\n12.425\n\n\nA. cinerea\nAMNH\n101635\nm1\n13.4\n\n\nA. cinerea\nAMNH\n101459\nm1\n14.4"
  },
  {
    "objectID": "old-posts.html",
    "href": "old-posts.html",
    "title": "Archived posts",
    "section": "",
    "text": "Archived posts\n\n\n\n\n\n\nNote\n\n\n\n↓ These are posts from a previous iteration of this blog.\n\n\n\n\n\n\n\n\n\n\n  Aug 12, 2015 — Making trees in the Jupyter notebook (part 2 - Bokeh) \n\n\n  Aug 7, 2015 — Making trees in the Jupyter notebook (part 1 - IToL) \n\n\n  Apr 20, 2015 — Melting your phyloseq object with dplyr/tidyr \n\n\n  Apr 17, 2015 — Evaluating 515F primers \n\n\n  Apr 14, 2015 — Exploring 515F primer targets in archaeal and bacterial SSU rRNA genes \n\n\n\nNo matching items"
  },
  {
    "objectID": "old-posts/trees2/index.html",
    "href": "old-posts/trees2/index.html",
    "title": "Making trees in the Jupyter notebook (part 2 - Bokeh)",
    "section": "",
    "text": "This post will work with the tree and information we produced in the last post. This time we’ll use a Python plotting library called Bokeh to visualize the tree.\nIToL is a great and flexible tool but on the flexibility front it can’t compete with charting libraries like Matplotlib, ggvis, ggplot2, or Bokeh. To demonstrate the power of such flexibility let’s make a tree with the new-ish Bokeh. There are several features I want to include in this visualization:\n\nI want the tree to be unrooted. I didn’t include an explicit outgroup in the tree from the previous post so I think it’s probably just best to display the tree in radial (as opposed to circular) format.\nI want the tips to show information when you mouse over them. I think interactive graphics are a great way to include collaborators in the data exploration. Also, interactive graphics can dramatically cut down on communication overhead. Luckily Bokeh makes adding hover interaction really easy as we’ll see.\nI want to add interaction that takes you to the protein webpage on GenBank when you click a tip node in the tree.\nLast, the tree figure should be “zoomable” so that users can drill down into the figure to investigate the details.\n\nOk, so (as always) we will first bring in all the modules we need. To get Bokeh plots to render inline in the Jupyter notebook you have to call the output_notebook function.\n\nfrom bokeh.io import output_notebook, show\nfrom bokeh.models.glyphs import Circle, Segment\nfrom bokeh.models import ColumnDataSource, Range1d, DataRange1d, Plot\nfrom cogent.draw.dendrogram import UnrootedDendrogram\nfrom cogent import LoadTree\nimport pandas as pd\nfrom bokeh.models import HoverTool, TapTool, BoxZoomTool, ResetTool, OpenURL\noutput_notebook()\n\n    \n        \n        \n        \n    \n        \n        BokehJS successfully loaded.\n    \n\n\nNext we’ll load our tree. I’m using pycogent for this post but there are many great tree objects and parsers out there for both Python and R. Pycogent was the only module that had code for plotting an unrooted tree layout that I could find. I didn’t do an exhaustiv search and I wouldn’t be surprise if there are other implementations. Biopython appears to use graphviz for displaying trees in the radial format and the network layout makes from some interesting looking trees. I prefer the unrooted tree layout algorithm in PyCogent. (FYI, I expect the tree layout code will be moved to scikit-bio at some point if it hasn’t already.)\nThe coords method below returns a 2D array where every row represents a node.\nThe rows/nodes information in the array are in order the node name, node ID, x position , y position, and a list of child nodes.\n\ntree = LoadTree(\"data/GH5.tree\")\ndendrogram = UnrootedDendrogram(tree)\ncoords = dendrogram.coords(500,500)\n\nNow I’ll define a couple functions to help us work with the coords array. The first just checks to see if the child nodes list is empty (an empty list denotes the node is a terminal node). The second function expands each row. That is to say it makes a row for each child of each parent node. This effectively converts our coords array from an array of nodes to an array of node connections. This is useful because when we plot the tree we are really drawing connections or edges as opposed to nodes. The expand functions skips terminal nodes (aka tips) because they don’t connect to any downstream nodes (hence “terminal”).\n\ndef is_tip(coord):\n    if not coord[-1]:\n        return True\n    else:\n        return False\n    \ndef expand(coords):\n    data = []\n    for coord in coords:\n        if is_tip(coord):\n            continue\n        else:\n            child_ids = coord[-1]\n            for child in child_ids:\n                l = coord[1:4]\n                l.append(child)\n                data.append(l)\n    return data\n\nWe will also want an dictionary of the x, y coordinates for each node keyed by node ID, a list/set of the tip node IDs, and a dictionary of tip node accessions keyed by corresponding node IDs. If you remember from our last post, the tree sequences are identified by their accession numbers and therefore each tip in the tree has an associated accession number.\n\nnode_locs = {r[1]: (r[2], r[3]) for r in coords}\nleaves = set([r[1] for r in coords if is_tip(r)])\nacc2id = {r[1] : r[0] for r in coords if is_tip(r)}\n\nLet’s also bring in the color definitions file from the last post. We uploaded this file to IToL last time to get the tree coloring we wanted. We’ll use it for the same purpose here.\n\ntip_info = pd.read_csv(\"data/color_defs.tsv\", sep=\"\\t\", header=None, names=[\"acc\",\"type\",\"color\",\"ec\"])\n\nAs I wrote above, we plot edges not nodes. So, I want a dataframe where each row represents an edge and has all the information I need for plotting that edge. This information includes the beginning and ending coordinates of the edge, the accession number for terminal edges, and a column denoting whether the edge leads to a tip or not.\n\ndf = pd.DataFrame(expand(coords), columns = [\"parent\",\"x0\",\"y0\",\"child\"])\ndf.set_index(\"parent\", inplace=True)\ndf[\"x1\"] = [node_locs[c][0] for c in df[\"child\"].values]\ndf[\"y1\"] = [node_locs[c][1] for c in df[\"child\"].values]\ndf[\"acc\"] = [acc2id[c] if c in acc2id else None for c in df[\"child\"].values]\ndf[\"is_tip\"] = [True if c in leaves else False for c in df[\"child\"]]\n\nNow I’ll merge the color definition file info to our edge dataframe. For convenience I also want a dataframe of just terminal edges (df_tips below).\n\ndf_all = pd.merge(df, tip_info, on=[\"acc\"], how=\"left\")\ndf_tips = df_all[df_all[\"is_tip\"]]\n\nThis is all the we need to make an unrooted tree figure in any charting library!\nTo make the tree in Bokeh I’m going to use the chart interface. First I’ll set up a dictionary of plot options.\n\nplot_options = dict(plot_width=800, plot_height=800, toolbar_location=None, \n                    outline_line_color=None, title = \"Characterized GH5 Tree\")\n\nNow I’ll make all the glyphs I want. We’ll use circle glyphs for terminal nodes and segment glyphs for edges. I am going to make the backbone tree in black and overlay segment glyphs for just the tip edges; the tip edges will be colored by their respective EC activities.\n\nradius = dict(value=1, units=\"data\")\n\nleaf_glyph = Circle(x=\"x1\", y=\"y1\", \n                    radius=radius, \n                    fill_color=\"#707070\", \n                    name=\"circles\", \n                    fill_alpha=0.5) \n\ntree_glyph = Segment(x0=\"x0\", y0=\"y0\", \n                     x1=\"x1\", y1=\"y1\", \n                     line_color=\"#151515\",\n                     line_alpha=0.75)\n\ntip_glyph = Segment(x0=\"x0\", y0=\"y0\", \n                     x1=\"x1\", y1=\"y1\", \n                     line_color=\"color\",\n                     line_width=1.65)\n\nWhen we add these glyphs to our plot we need to upload a corresponding ColumnDataSource. This function just converts or Pandas dataframes to Bokeh data sources.\n\ndef df2ds(df):\n    return ColumnDataSource(ColumnDataSource.from_df(df))\n\nBelow I make the plot and add the glyphs.\n\nydr = DataRange1d(range_padding=0.05)  \nxdr = DataRange1d(range_padding=0.05)  \n\nplot = Plot(x_range=xdr, y_range=ydr, **plot_options)\nplot.add_glyph(df2ds(df_all), tree_glyph)\nplot.add_glyph(df2ds(df_tips), tip_glyph)\nplot.add_glyph(df2ds(df_tips), leaf_glyph)\n\n&lt;bokeh.models.renderers.GlyphRenderer at 0x7f528b5c5a10&gt;\n\n\n…and we render the plot inline with the show command. Voila! Pretty cool but no interaction yet…\n\nshow(plot)\n\n\n\n\n\n\nLet’s make the same plot with the hover and zoom action. We start as before but this time I’m going to put a toolbar on the plot that will let us hit a reset button to get back the original figure (It’s pretty essential to add the reset function in addition to box zoom).\n\nplot_options = dict(plot_width=800, plot_height=800, toolbar_location=\"left\", \n                    outline_line_color=None, title = \"Characterized GH5 Tree\")\n\nydr = DataRange1d(range_padding=0.05)  \nxdr = DataRange1d(range_padding=0.05)  \n\nplot = Plot(x_range=xdr, y_range=ydr, **plot_options)\nplot.add_glyph(df2ds(df_all), tree_glyph)\nplot.add_glyph(df2ds(df_tips), tip_glyph)\nleaf = plot.add_glyph(df2ds(df_tips), leaf_glyph)\n\nLet’s make the hover tool tip. It’s just defined in html. I want to display the accession and EC information for each tip (add and “@” symbol to denote columns in the data source that you want to display in the tooltip).\n\ntooltip = \"\"\"\n    &lt;div&gt;\n        &lt;span style=\"font-size: 17px; font-weight: bold;\"&gt;accession: &lt;/span&gt;\n        &lt;span style=\"font-size: 15px; color: #151515;\"&gt;@acc&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;span style=\"font-size: 17px; font-weight: bold;\"&gt;EC: &lt;/span&gt;\n        &lt;span style=\"font-size: 15px; color: #151515;\"&gt;@ec&lt;/span&gt;\n    &lt;/div&gt;\n\"\"\"\n\nNow we make our hover tool and add it to the plot. Be cause we assigned the renderer for our “nodes” (i.e. leaf) we can specify that we want this hover tool to be specific to that glyph in the plot.\n\nhover = HoverTool(renderers = [leaf], tooltips=tooltip)\nplot.add_tools(hover, BoxZoomTool(), ResetTool())\n\nNow hover over the points to see the accession and EC information for each tip. Also note the toolbar on the left. You can box zoom into the tree with your mouse to explore the topology at better resolution. Try it out! The reset button will get you back to the original orientation.\n\nshow(plot)\n\n\n\n\n\n\nThat’s everything I wanted to do except for the click action. As I stated above, it would be great if clicking on tip nodes brought you to the GenBank webpage for the protein that the each node represents. We can get this interaction with the tap tool. The following is a bit of a hack but the url takes the accession info and returns a url to a CGI script that searches the GenBank protein database for that accession value. In the end, clicking a tip takes you to a GenBank page. Give it a shot!\n\ntaptool = TapTool(action=OpenURL(url=\"http://www.ncbi.nlm.nih.gov/protein/?term=@acc%5Bacc%5D\"))\n\n\nplot_options = dict(plot_width=800, plot_height=800, toolbar_location=\"left\", \n                    outline_line_color=None, title = \"Characterized GH5 Tree\")\n\nydr = DataRange1d(range_padding=0.05)  \nxdr = DataRange1d(range_padding=0.05)  \n\nplot = Plot(x_range=xdr, y_range=ydr, **plot_options)\nplot.add_glyph(df2ds(df_all), tree_glyph)\nplot.add_glyph(df2ds(df_tips), tip_glyph)\nleaf = plot.add_glyph(df2ds(df_tips), leaf_glyph)\n\nhover = HoverTool(renderers =[leaf],tooltips=tooltip)\nplot.add_tools(hover, BoxZoomTool(), ResetTool(), taptool)\n\nshow(plot)\n\n\n\n\n\n\nThis would be a great way to show some results to collaborators without having to clobber it all up with a bunch of labels. And the syntax is really concise. Bokeh is an exciting tool that allows you to make clean, rich visualizations quickly and in my experience it works seamlessly with the Jupyter notebook. Exciting stuff!!!"
  },
  {
    "objectID": "old-posts/primers2/index.html",
    "href": "old-posts/primers2/index.html",
    "title": "Evaluating 515F primers",
    "section": "",
    "text": "Before we begin, I stumbled across this really great blog post from the Knight lab that you should definitely check out if you’re interested in SSU rRNA gene primers. They have some experimental data up which is great to see.\nLet’s start by summarizing a few key findings from the last post.\n\nThe 515F target in Bacteria is extremely conserved – one sequence is found many many times more than any other.\nAlthough the bacterial 515F targets are predominantly one sequence, the second and third most abundant bacterial 515F targets differ from the most abundant target near the 3’ end.\nThe 515F targets in Archaea and Bacteria have little overlap.\nArchaeal 515F targets are more evenly distributed than bacterial 515F targets.\nThe Nanoarchaea appear to have a diagnostic 515F sequence.\n\nBased on these findings we might ask a few questions:\n\nDoes the 515F primer account for the 3’ differences between the three most abundant bacterial targets? If not, what are the implications?\nDoes 515F hit Archaea and Bacteria equally well?\nDoes 515F hit Nanoarchaea in particular?\n\nThe questions above imply one version of 515F. In reality, the 515F primer has been modified over time so we should address those questions over a representative collection of 515F primers.\nIn this post we’ll look at two 515F versions and propose an updated version and see how it compares. Let’s evaluate the 515F version used by Bates et al. (2010) because the authors provide a nice primer analysis in their paper. We’ll also look at the 515F version that is on the Earth Microbiome Project (EMP) website.\nI’m just going to use the regex Python module (here) to evaluate the primers. We need to represent the primers with the degeneracy in regular expression syntax. The {e} at the end will allow us to enable fuzzy matching.\n\nversions = {\"EMP\" : \"(GTG[CT]CAGC[CA]GCCGCGGTAA){e}\", \n            \"Bates\" : \"(GTGCCAGC[CA]GCCGCGGTAA){e}\"}\n\nOk, let’s bring in the Python modules we need and some IPython extensions.\n\n%matplotlib inline\n%load_ext rpy2.ipython\nimport matplotlib.pyplot as plt\nfrom align import aligner\nfrom skbio import DNA, parse_fasta, SequenceCollection\nimport pandas as pd\nimport regex\n\n\n%%R\nlibrary(ggplot2)\nlibrary(dplyr); library(tidyr)\nlibrary(magrittr)\nlibrary(RColorBrewer)\nlibrary(gridExtra)\n\nWe’ll make the same 515F target dataframe as in the previous post.\n\ndef parse_tax(line):\n    id, tax_str = line.split(\"\\t\")\n    k, p, c, o, f, g, s = tax_str.rstrip().split(\";\")\n    tax_dict = {\"kingdom\" : k.split(\"__\")[1],\n                \"phylum\"  : p.split(\"__\")[1],\n                \"class\"   : c.split(\"__\")[1],\n                \"family\"  : f.split(\"__\")[1],\n                \"order\"   : o.split(\"__\")[1],\n                \"genus\"   : g.split(\"__\")[1],\n                \"species\" : s.split(\"__\")[1],\n                \"id\"      : id}\n    return tax_dict\n    \n\ndf = pd.DataFrame.from_records([parse_tax(line) for line in \n                                open(\"data/gg_13_5_otus/taxonomy/99_otu_taxonomy.txt\")])\n\ndf.set_index(\"id\", inplace=True)\n\nfn = \"data/gg_13_5_otus/rep_set/99_otus.fasta\"\ndegens = DNA.iupac_degenerate_characters()\nseqs = SequenceCollection.from_fasta_records([(n, s) for n, s in parse_fasta(fn) \n                                              if not any(i in s for i in degens)], \n                                             DNA)\n\nids = [seq[0] for seq in seqs.iteritems()]\n\nF515 = DNA(\"GTGCCAGCCGCCGCGGTAA\") #GTGCCAGCMGCCGCGGTAA  M = [CA]\n\nprimer_targets_515 = [aligner(F515.sequence, \n                              seq[1].sequence,\n                              method = \"glocal\")[1] \n                      for seq in seqs.iteritems()]\n\ndf_targets = df.join(pd.Series(primer_targets_515, index=ids, name = \"515F\"), how = \"left\")\ndf_targets.dropna(axis=0, subset=[\"515F\"], inplace=True)\n\nOk, now the fun stuff. Let’s define a function that counts substitutions between the target and the primer. If there’s an indel in the target, this function returns an empty string. Eventually we’ll pass this dataframe into R and it’s easy to replace empty strings with R NA values. One quick note: we’ll just be working with the ten most abundant targets in Bacteria and Archaea for the following figures.\n\ndef count_subs(s, primer_regex):\n    subs, ins, dels = regex.fullmatch(primer_regex, s).fuzzy_counts\n    if ins or dels:\n        return \"\"\n    else:\n        return subs\n\nNow we’ll add a column to the target dataframe for each primer version. The values are the number of substitutions between the target and the primer.\n\nfor key in versions:\n    df_targets[key] = df_targets[\"515F\"].apply(lambda x: count_subs(x, versions[key]))\n\nPush the dataframe into R and we’re ready to go! I want to make a figure that conveys three bits of information:\n\nThe target,\nthe number of mismatches between the primer and the target, and\nthe representation of the target in selected taxonomic groups.\n\nSo, let’s make a heatmap (sort of) figure where columns are targets (10 most abundant archaeal and bacterial), rows represent 515F primer versions and the color of each cell represents the mismatches between primer and target. We can scale the size of each cell to the count of each target within the given taxon (log scaled).\n\n%R -i df_targets\n\n\n\nCode\n%%R -w 650\nd = df_targets %&gt;%\n    group_by(kingdom, X515F) %&gt;%\n    summarize(count = n(), EMP = first(EMP), Bates = first(Bates)) %&gt;%\n    filter(rank(desc(count), ties.method = \"random\") &lt;= 10) %&gt;%\n    arrange(desc(count), kingdom) %&gt;%\n    mutate(X515F = factor(X515F, levels = unique(.$X515F))) %&gt;% \n    {\n        .[.==\"\"] = NA\n        .\n    } %&gt;%\n    gather(key, value, -count, -kingdom, -X515F)\n\np = ggplot(d, aes(x = X515F, y = key, size = log(count), fill = value))\n\np = p + facet_wrap(~kingdom, ncol = 1, scales = \"free_y\")\n\np = p + geom_point(shape = 22)\n\np = p + scale_size_area(max_size = 14)\n\np = p + scale_fill_manual(values = brewer.pal(4,\"RdYlBu\"), na.value = \"grey70\")\n\np = p + labs(x = \"\", y = \"\", fill = \"# mismatches\")\n\np = p + theme_bw()\n\np = p + theme(axis.text.x = element_text(angle = 65, hjust = 1, size = 14, family = \"mono\"),\n              axis.text.y = element_text(size = 12),\n              axis.title = element_text(size = 16),\n              strip.background = element_blank(),\n              strip.text = element_text(size = 16),\n              legend.text = element_text(size = 12),\n              legend.title = element_text(size = 16))\n\np = p + guides(fill = guide_legend(override.aes=list(size=5)), size = FALSE)\n\np\n\n\n\n\n\n\n\n\n\nCool! You can see that the EMP primer has improved zero mismatch coverage of Archaea (also discussed in this post). There are still mismatches at the 3’ end between second and third most abundant bacterial 515F targets with each primer version.\nLet’s explore what the implications of the 3’ end mismatch between primers and bacterial targets might be. I want to look at how each primer hits bacterial phyla. Let’s define a function to make this plot. The function will take a couple arguments. One argument will specify the taxon to plot (right now just Bacteria or Archaea) and the other will specify the primer. In this figure rows will be targets (10 most abundant targets) and columns will be taxa. The colors will represent mismatches against the selected primer. Size will be based on relative abundance for the target within the given column. These figures are somewhat small but you can zoom in by right clicking and opening the figure in a new browser window or tab.\n\n\nCode\n%%R -w 1300 -h 1000\nprimer_plot = function(taxon = \"Bacteria\", primer = \"EMP\") {\n    d = df_targets %&gt;%\n        {\n            .[.==\"\"] = NA\n            .\n        } %&gt;%\n        filter(!is.na(phylum), kingdom == taxon) %&gt;%\n        {\n            psort = group_by(., phylum) %&gt;% \n                summarize(count = n()) %&gt;% \n                arrange(desc(count)) %&gt;%\n                extract2(\"phylum\") %&gt;% as.character\n            mutate(., phylum = factor(phylum, levels = psort))\n        } %&gt;%\n        group_by(phylum, X515F) %&gt;%\n        do(summarize(., count = n(), primer = first(.[[primer]]))) %&gt;%\n        group_by(phylum) %&gt;%\n        mutate(count.relative = count / sum(count)) %&gt;%\n        {\n            keep = group_by(., X515F) %&gt;%\n                summarize(tmp = sum(count)) %&gt;%\n                filter(rank(desc(tmp), ties.method = \"random\") &lt;= 10) %&gt;%\n                arrange(tmp) %&gt;%\n                extract2(\"X515F\") %&gt;% as.character\n            filter(., X515F %in% keep) %&gt;%\n                mutate(X515F = factor(X515F, levels = keep), primer = factor(primer, levels = 0:4))\n        }\n\n\n    p = ggplot(d, aes(x = X515F, y = phylum, size = log(count.relative), fill = primer))\n               \n    p = p + geom_point(shape = 22, alpha = 0.75)\n\n    p = p + labs(x = \"\", y = \"\", fill = \"# mismatches\")\n\n    p = p + scale_fill_manual(values = brewer.pal(4,\"RdYlBu\"), na.value = \"grey70\")\n    \n    p = p + ggtitle(paste(\"Figure for the \", primer, \"515F primer\"))\n\n    p = p + theme_bw()\n\n    p = p + theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust = 0.5, size = 12),\n                  axis.text.y = element_text(size = 16, family = \"mono\"),\n                  axis.title = element_text(size = 16),\n                  strip.background = element_blank(),\n                  legend.text = element_text(size = 12),\n                  legend.title = element_text(size = 16),\n                  strip.text = element_blank())\n\n    p = p + guides(fill = guide_legend(override.aes=list(size=5)), size = FALSE)\n\n    p = p + coord_flip()\n\n    p\n}\n\ngrid.arrange(primer_plot(), primer_plot(primer = \"Bates\"), nrow = 2)\n\n\n\n\n\n\n\n\n\nAs you can see, the 3’ mismatch will probably effect recovery of TM7 as well as a smattering of sequences throughout the most abundant phyla.\nWe can make the same plot for Archaea. This highlights how the EMP 515F version hits the Crenarchaea with zero mismatches but neither primer matches the Nanoarchaea targets well.\n\n%%R -w 1200 -h 400\ngrid.arrange(primer_plot(taxon = \"Archaea\"), \n             primer_plot(taxon = \"Archaea\", primer = \"Bates\"), ncol = 2)\n\n\n\n\n\n\n\n\nIt’s a bit unrealistic to design the perfect primer. But, it’s certainly possible to quantify and explore in silico primer bias and to interpret results with the bias in mind. It’s really great to see how the EMP folks have improved the 515F primer to hit more Crenarchaea. One suggestion from our analysis today is to add degeneracy at the 3’ end to account for TM7 and many members of more abundant groups. The current EMP 515F primer is 5’-GTGYCAGCMGCCGCGGTAA-3’ but it might be useful to change that to 5’-GTGYCAGCMGCCGCGGTVA-3’.\nI’m also wondering if you could just chop off the last two nucleotides? This would drop the annealing temp but perhaps it would be negligible(?).\nHere is what the proposed 515F looks like against Bacteria. You can see that it hits TM7 and the second most abundant target with zero mismatches.\n\ndf_targets[\"proposed\"] = df_targets[\"515F\"].apply(lambda x: count_subs(x, \"(GTG[CT]CAGC[CA]GCCGCGGT[AGC]A){e}\"))\n%R -i df_targets\n\n\n%%R -w 1300 -h 500\nprimer_plot(primer = \"proposed\")\n\n\n\n\n\n\n\n\nAnd we can address the questions from above.\n\nDo 515F primers account for the 3’ differences between the three most abundant targets? If not, what are the implications?\n\n\nNo. Current 515F primers are biased against TM7 and have mismatches at the 3’ end with sequences throughout the most commonly found bacterial phyla (although current primers do hit the most abundant target in Archaea and Bacteria with zero mismatches and there’s only one mismatch between current targets and most bacterial targets). So, on the whole, the latest primers are great but still room for improvement.\n\n\nDoes 515F hit Archaea and Bacteria equally well?\n\n\nI would say yes, tentatively. The latest EMP primer appears to hit most Archaea with zero mismatches. It also hits most Bacteria with one mismatch or less.\n\n\nDoes 515F hit Nanoarchaea in particular?\n\n\nNo. Nanoarchaea have distinct 515F targets and 515F primers are biased against Nanoarchaea in silico."
  }
]